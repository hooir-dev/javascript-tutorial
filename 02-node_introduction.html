<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS 中可以提升幸福度的小技巧 | javascript 学习总结</title>
    <meta name="description" content="持续更新中...">
    
    
    <link rel="preload" href="/assets/css/0.styles.bc72b5c6.css" as="style"><link rel="preload" href="/assets/js/app.fa27fcb7.js" as="script"><link rel="preload" href="/assets/js/7.ebbd53f9.js" as="script"><link rel="prefetch" href="/assets/js/10.50f8cc69.js"><link rel="prefetch" href="/assets/js/11.63165319.js"><link rel="prefetch" href="/assets/js/12.c77fd109.js"><link rel="prefetch" href="/assets/js/13.d3bcb504.js"><link rel="prefetch" href="/assets/js/14.2ab5316d.js"><link rel="prefetch" href="/assets/js/15.50e05516.js"><link rel="prefetch" href="/assets/js/16.cc4e9e6b.js"><link rel="prefetch" href="/assets/js/17.cf8a5144.js"><link rel="prefetch" href="/assets/js/18.995ea2c3.js"><link rel="prefetch" href="/assets/js/19.b53dbd1f.js"><link rel="prefetch" href="/assets/js/2.24befd02.js"><link rel="prefetch" href="/assets/js/20.4f10ac6f.js"><link rel="prefetch" href="/assets/js/21.a93f4746.js"><link rel="prefetch" href="/assets/js/3.c69e2e19.js"><link rel="prefetch" href="/assets/js/4.da806239.js"><link rel="prefetch" href="/assets/js/5.953b51b4.js"><link rel="prefetch" href="/assets/js/6.f74ce3b5.js"><link rel="prefetch" href="/assets/js/8.5ea0397d.js"><link rel="prefetch" href="/assets/js/9.396e3ff8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.bc72b5c6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">javascript 学习总结</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="http://liuyang.feblog.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  刘洋博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">学习文档</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="http://vuejs.feblog.cn/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  vue
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://nodejs.feblog.cn/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  nodejs
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <a href="https://github.com/thisliuyang/javascript-tutorial" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="http://liuyang.feblog.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  刘洋博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">学习文档</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="http://vuejs.feblog.cn/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  vue
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://nodejs.feblog.cn/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  nodejs
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <a href="https://github.com/thisliuyang/javascript-tutorial" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/00-javascript.html" class="sidebar-link">Javascript基础</a></li><li><a href="/01-web_concept.html" class="sidebar-link">Javascript 的 this 用法</a></li><li><a href="/02-node_introduction.html" class="active sidebar-link">JS 中可以提升幸福度的小技巧</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_1-类型强制转换" class="sidebar-link">1. 类型强制转换</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_1-1-string强制转换为数字" class="sidebar-link">1.1 string强制转换为数字</a></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_1-2-object强制转化为string" class="sidebar-link">1.2 object强制转化为string</a></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_1-3-使用boolean过滤数组中的所有假值" class="sidebar-link">1.3 使用Boolean过滤数组中的所有假值</a></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_1-4-双位运算符" class="sidebar-link">1.4 双位运算符 ~~</a></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_1-5-短路运算符" class="sidebar-link">1.5 短路运算符</a></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_1-6-取整-0" class="sidebar-link">1.6 取整 | 0</a></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_1-7-判断奇偶数-1" class="sidebar-link">1.7 判断奇偶数 &amp; 1</a></li></ul></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_2-函数" class="sidebar-link">2. 函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_2-1-函数默认值" class="sidebar-link">2.1 函数默认值</a></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_2-2-强制参数" class="sidebar-link">2.2 强制参数</a></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_2-3-隐式返回值" class="sidebar-link">2.3 隐式返回值</a></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_2-4-惰性载入函数" class="sidebar-link">2.4 惰性载入函数</a></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_2-5-一次性函数" class="sidebar-link">2.5 一次性函数</a></li></ul></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_3-字符串" class="sidebar-link">3. 字符串</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_3-1-字符串比较时间先后" class="sidebar-link">3.1 字符串比较时间先后</a></li></ul></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_4-数字" class="sidebar-link">4. 数字</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_4-1-不同进制表示法" class="sidebar-link">4.1 不同进制表示法</a></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_4-2-精确到指定位数的小数" class="sidebar-link">4.2 精确到指定位数的小数</a></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_4-3-数字补0操作" class="sidebar-link">4.3 数字补0操作</a></li></ul></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_5-数组" class="sidebar-link">5. 数组</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_5-1-reduce方法同时实现map和filter" class="sidebar-link">5.1 reduce方法同时实现map和filter</a></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_5-2-统计数组中相同项的个数" class="sidebar-link">5.2 统计数组中相同项的个数</a></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_5-3-使用解构来交换参数数值" class="sidebar-link">5.3 使用解构来交换参数数值</a></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_5-4-接收函数返回的多个结果" class="sidebar-link">5.4 接收函数返回的多个结果</a></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_5-5-将数组平铺到指定深度" class="sidebar-link">5.5 将数组平铺到指定深度</a></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_5-6-数组的对象解构" class="sidebar-link">5.6 数组的对象解构</a></li></ul></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_6-对象" class="sidebar-link">6. 对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_6-1-使用解构删除不必要属性" class="sidebar-link">6.1 使用解构删除不必要属性</a></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_6-2-在函数参数中解构嵌套对象" class="sidebar-link">6.2 在函数参数中解构嵌套对象</a></li></ul></li><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_7-代码复用" class="sidebar-link">7. 代码复用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/02-node_introduction.html#_7-1-object-key" class="sidebar-link">7.1 Object [key]</a></li></ul></li></ul></li><li><a href="/03-getting_started.html" class="sidebar-link">Vue.js双向绑定的实现原理</a></li><li><a href="/04-module.html" class="sidebar-link">常用 Git 命令清单</a></li><li><a href="/05-package_npm.html" class="sidebar-link">浏览器同源政策及其规避方法</a></li><li><a href="/06-fs.html" class="sidebar-link">深入理解函数作用域之形参作用域</a></li><li><a href="/07-web.html" class="sidebar-link">数组的几个不 low 操作</a></li><li><a href="/08-express.html" class="sidebar-link">选择排序、桶排序、冒泡排序和快速排序</a></li><li><a href="/09-db.html" class="sidebar-link">window 对象</a></li><li><a href="/10-web_db.html" class="sidebar-link">XMLHttpRequest 对象</a></li><li><a href="/11-session_persistence.html" class="sidebar-link">Promise 对象</a></li><li><a href="/12-ajax.html" class="sidebar-link">Document 节点</a></li><li><a href="/13-alibaixiu.html" class="sidebar-link">Element 节点</a></li><li><a href="/14-asynchronous_ programming.html" class="sidebar-link">异步操作概述</a></li><li><a href="/15-dep_ops.html" class="sidebar-link">鼠标事件</a></li><li><a href="/16-other.html" class="sidebar-link">js常用函数</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="js-中可以提升幸福度的小技巧"><a href="#js-中可以提升幸福度的小技巧" aria-hidden="true" class="header-anchor">#</a> JS 中可以提升幸福度的小技巧</h1> <h2 id="_1-类型强制转换"><a href="#_1-类型强制转换" aria-hidden="true" class="header-anchor">#</a> 1. 类型强制转换</h2> <h3 id="_1-1-string强制转换为数字"><a href="#_1-1-string强制转换为数字" aria-hidden="true" class="header-anchor">#</a> 1.1 string强制转换为数字</h3> <p>可以用<code>*1</code>来转化为数字(实际上是调用<code>.valueOf</code>方法) 然后使用<code>Number.isNaN</code>来判断是否为<code>NaN</code>，或者使用 <code>a !== a</code> 来判断是否为<code>NaN</code>，因为 <code>NaN !== NaN</code></p> <div class="language- extra-class"><pre class="language-text"><code>'32' * 1            // 32
'ds' * 1            // NaN
null * 1            // 0
undefined * 1    // NaN
1  * { valueOf: ()=&gt;'3' }        // 3
复制代码
</code></pre></div><p><strong>常用：</strong> 也可以使用<code>+</code>来转化字符串为数字</p> <div class="language- extra-class"><pre class="language-text"><code>+ '123'            // 123
+ 'ds'               // NaN
+ ''                    // 0
+ null              // 0
+ undefined    // NaN
+ { valueOf: ()=&gt;'3' }    // 3
复制代码
</code></pre></div><h3 id="_1-2-object强制转化为string"><a href="#_1-2-object强制转化为string" aria-hidden="true" class="header-anchor">#</a> 1.2 object强制转化为string</h3> <p>可以使用 <code>字符串+Object</code> 的方式来转化对象为字符串(实际上是调用 <code>.toString()</code> 方法)</p> <div class="language- extra-class"><pre class="language-text"><code>'the Math object:' + Math                // &quot;the Math object:[object Math]&quot;
'the JSON object:' + JSON              // &quot;the JSON object:[object JSON]&quot;
复制代码
</code></pre></div><p>当然也可以覆盖对象的<code>toString</code>和<code>valueOf</code>方法来自定义对象的类型转换：</p> <div class="language- extra-class"><pre class="language-text"><code>2  * { valueOf: ()=&gt;'3' }                // 6
'J' + { toString: ()=&gt;'S' }                // &quot;JS&quot;
复制代码
</code></pre></div><blockquote><p>《Effective JavaScript》P11：当<code>+</code>用在连接字符串时，当一个对象既有<code>toString</code>方法又有<code>valueOf</code>方法时候，JS通过盲目使用<code>valueOf</code>方法来解决这种含糊。 对象通过<code>valueOf</code>方法强制转换为数字，通过<code>toString</code>方法强制转换为字符串</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>'' + {toString:()=&gt;'S',valueOf:()=&gt;'J'}                // J
复制代码
</code></pre></div><h3 id="_1-3-使用boolean过滤数组中的所有假值"><a href="#_1-3-使用boolean过滤数组中的所有假值" aria-hidden="true" class="header-anchor">#</a> 1.3 使用Boolean过滤数组中的所有假值</h3> <p>我们知道JS中有一些假值：<code>false</code>，<code>null</code>，<code>0</code>，<code>&quot;&quot;</code>，<code>undefined</code>，<code>NaN</code>，怎样把数组中的假值快速过滤呢，可以使用Boolean构造函数来进行一次转换</p> <div class="language- extra-class"><pre class="language-text"><code>const compact = arr =&gt; arr.filter(Boolean)
compact([0, 1, false, 2, '', 3, 'a', 'e' * 23, NaN, 's', 34])             // [ 1, 2, 3, 'a', 's', 34 ]
复制代码
</code></pre></div><h3 id="_1-4-双位运算符"><a href="#_1-4-双位运算符" aria-hidden="true" class="header-anchor">#</a> 1.4 双位运算符 ~~</h3> <p>可以使用双位操作符来替代正数的 <code>Math.floor( )</code>，替代负数的<code>Math.ceil( )</code>。双否定位操作符的优势在于它执行相同的操作运行速度更快。</p> <div class="language- extra-class"><pre class="language-text"><code>Math.floor(4.9) === 4      //true
// 简写为：
~~4.9 === 4      //true
复制代码
</code></pre></div><p>不过要注意，对正数来说 <code>~~</code> 运算结果与 <code>Math.floor( )</code> 运算结果相同，而对于负数来说与<code>Math.ceil( )</code>的运算结果相同：</p> <div class="language- extra-class"><pre class="language-text"><code>~~4.5                // 4
Math.floor(4.5)      // 4
Math.ceil(4.5)       // 5

~~-4.5        		// -4
Math.floor(-4.5)     // -5
Math.ceil(-4.5)      // -4
复制代码
</code></pre></div><h3 id="_1-5-短路运算符"><a href="#_1-5-短路运算符" aria-hidden="true" class="header-anchor">#</a> 1.5 短路运算符</h3> <p>我们知道逻辑与<code>&amp;&amp;</code>与逻辑或<code>||</code>是短路运算符，短路运算符就是从左到右的运算中前者满足要求，就不再执行后者了； 可以理解为：</p> <ul><li><code>&amp;&amp;</code>为取假运算，从左到右依次判断，如果遇到一个假值，就返回假值，以后不再执行，否则返回最后一个真值</li> <li><code>||</code>为取真运算，从左到右依次判断，如果遇到一个真值，就返回真值，以后不再执行，否则返回最后一个假值</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let param1 = expr1 &amp;&amp; expr2
let param2 = expr1 || expr2
复制代码
</code></pre></div><table><thead><tr><th>运算符</th> <th>示例</th> <th>说明</th></tr></thead> <tbody><tr><td><code>&amp;&amp;</code></td> <td><code>expr1&amp;&amp;expr2</code></td> <td>如果expr1 能转换成false则返回expr1,否则返回expr2. 因此, 在Boolean环境中使用时, 两个操作结果都为true时返回true,否则返回false.</td></tr> <tr><td>||</td> <td>expr1||expr2</td> <td>如果expr1能转换成true则返回expr1,否则返回expr2. 因此,在boolean环境(在if的条件判断中)中使用时, 二者操作结果中只要有一个为true,返回true;二者操作结果都为false时返回false.</td></tr> <tr><td><code>!</code></td> <td><code>!expr</code></td> <td>如果单个表达式能转换为true的话返回false,否则返回true.</td></tr></tbody></table> <p>因此可以用来做很多有意思的事，比如给变量赋初值：</p> <div class="language- extra-class"><pre class="language-text"><code>let variable1
let variable2 = variable1  || 'foo'
复制代码
</code></pre></div><p>如果variable1是真值就直接返回了，后面短路就不会被返回了，如果为假值，则会返回后面的<code>foo</code>。</p> <p>也可以用来进行简单的判断，取代冗长的<code>if</code>语句：</p> <div class="language- extra-class"><pre class="language-text"><code>let variable = param &amp;&amp; param.prop
复制代码
</code></pre></div><p>如果<code>param</code>如果为真值则返回<code>param.prop</code>属性，否则返回<code>param</code>这个假值，这样在某些地方防止<code>param</code>为<code>undefined</code>的时候还取其属性造成报错。</p> <h3 id="_1-6-取整-0"><a href="#_1-6-取整-0" aria-hidden="true" class="header-anchor">#</a> 1.6 取整 <code>| 0</code></h3> <p>对一个数字<code>| 0</code>可以取整，负数也同样适用，<code>num | 0</code></p> <div class="language- extra-class"><pre class="language-text"><code>1.3 | 0         // 1
-1.9 | 0        // -1
复制代码
</code></pre></div><h3 id="_1-7-判断奇偶数-1"><a href="#_1-7-判断奇偶数-1" aria-hidden="true" class="header-anchor">#</a> 1.7 判断奇偶数 <code>&amp; 1</code></h3> <p>对一个数字<code>&amp; 1</code>可以判断奇偶数，负数也同样适用，<code>num &amp; 1</code></p> <div class="language- extra-class"><pre class="language-text"><code>const num=3;
!!(num &amp; 1)                    // true
!!(num % 2)                    // true
复制代码
</code></pre></div><h2 id="_2-函数"><a href="#_2-函数" aria-hidden="true" class="header-anchor">#</a> 2. 函数</h2> <h3 id="_2-1-函数默认值"><a href="#_2-1-函数默认值" aria-hidden="true" class="header-anchor">#</a> 2.1 函数默认值</h3> <div class="language- extra-class"><pre class="language-text"><code>func = (l, m = 3, n = 4 ) =&gt; (l * m * n);
func(2)             //output: 24
复制代码
</code></pre></div><p>注意，传入参数为<code>undefined</code>或者不传入的时候会使用默认参数，但是传入<code>null</code>还是会覆盖默认参数。</p> <h3 id="_2-2-强制参数"><a href="#_2-2-强制参数" aria-hidden="true" class="header-anchor">#</a> 2.2 强制参数</h3> <p>默认情况下，如果不向函数参数传值，那么JS 会将函数参数设置为<code>undefined</code>。其它一些语言则会发出警告或错误。要执行参数分配，可以使用<code>if</code>语句抛出未定义的错误，或者可以利用<code>强制参数</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>mandatory = ( ) =&gt; {
  throw new Error('Missing parameter!');
}
foo = (bar = mandatory( )) =&gt; {     // 这里如果不传入参数，就会执行manadatory函数报出错误
  return bar;
}
复制代码
</code></pre></div><h3 id="_2-3-隐式返回值"><a href="#_2-3-隐式返回值" aria-hidden="true" class="header-anchor">#</a> 2.3 隐式返回值</h3> <p>返回值是我们通常用来返回函数最终结果的关键字。只有一个语句的箭头函数，可以隐式返回结果（函数必须省略大括号<code>{ }</code>，以便省略返回关键字）。</p> <p>要返回多行语句（例如对象文本），需要使用<code>( )</code>而不是<code>{ }</code>来包裹函数体。这样可以确保代码以单个语句的形式进行求值。</p> <div class="language- extra-class"><pre class="language-text"><code>function calcCircumference(diameter) {
  return Math.PI * diameter
}
// 简写为：
calcCircumference = diameter =&gt; (
  Math.PI * diameter;
)
复制代码
</code></pre></div><h3 id="_2-4-惰性载入函数"><a href="#_2-4-惰性载入函数" aria-hidden="true" class="header-anchor">#</a> 2.4 惰性载入函数</h3> <p>在某个场景下我们的函数中有判断语句，这个判断依据在整个项目运行期间一般不会变化，所以判断分支在整个项目运行期间只会运行某个特定分支，那么就可以考虑惰性载入函数</p> <div class="language- extra-class"><pre class="language-text"><code>function foo(){
    if(a !== b){
        console.log('aaa')
    }else{
        console.log('bbb')
    }
}
 
// 优化后
function foo(){
    if(a != b){
        foo = function(){
            console.log('aaa')
        }
    }else{
        foo = function(){
            console.log('bbb')
        }
    }
    return foo();
}
复制代码
</code></pre></div><p>那么第一次运行之后就会覆写这个方法，下一次再运行的时候就不会执行判断了。当然现在只有一个判断，如果判断很多，分支比较复杂，那么节约的资源还是可观的。</p> <h3 id="_2-5-一次性函数"><a href="#_2-5-一次性函数" aria-hidden="true" class="header-anchor">#</a> 2.5 一次性函数</h3> <p>跟上面的惰性载入函数同理，可以在函数体里覆写当前函数，那么可以创建一个一次性的函数，重新赋值之前的代码相当于只运行了一次，适用于运行一些只需要执行一次的初始化代码</p> <div class="language- extra-class"><pre class="language-text"><code>var sca = function() {
    console.log('msg')
    sca = function() {
        console.log('foo')
    }
}
sca()        // msg
sca()        // foo
sca()        // foo
复制代码
</code></pre></div><h2 id="_3-字符串"><a href="#_3-字符串" aria-hidden="true" class="header-anchor">#</a> 3. 字符串</h2> <h3 id="_3-1-字符串比较时间先后"><a href="#_3-1-字符串比较时间先后" aria-hidden="true" class="header-anchor">#</a> 3.1 字符串比较时间先后</h3> <p>比较时间先后顺序可以使用字符串：</p> <div class="language- extra-class"><pre class="language-text"><code>var a = &quot;2014-08-08&quot;;
var b = &quot;2014-09-09&quot;;
 
console.log(a&gt;b, a&lt;b); // false true
console.log(&quot;21:00&quot;&lt;&quot;09:10&quot;);  // false
console.log(&quot;21:00&quot;&lt;&quot;9:10&quot;);   // true   时间形式注意补0
复制代码
</code></pre></div><p>因为字符串比较大小是按照字符串从左到右每个字符的<code>charCode</code>来的，但所以特别要注意时间形式注意补0</p> <h2 id="_4-数字"><a href="#_4-数字" aria-hidden="true" class="header-anchor">#</a> 4. 数字</h2> <h3 id="_4-1-不同进制表示法"><a href="#_4-1-不同进制表示法" aria-hidden="true" class="header-anchor">#</a> 4.1 不同进制表示法</h3> <p>ES6中新增了不同进制的书写格式，在后台传参的时候要注意这一点。</p> <div class="language- extra-class"><pre class="language-text"><code>29            // 10进制
035            // 8进制29      原来的方式
0o35            // 8进制29      ES6的方式
0x1d            // 16进制29
0b11101            // 2进制29
复制代码
</code></pre></div><h3 id="_4-2-精确到指定位数的小数"><a href="#_4-2-精确到指定位数的小数" aria-hidden="true" class="header-anchor">#</a> 4.2 精确到指定位数的小数</h3> <p>将数字四舍五入到指定的小数位数。使用 <code>Math.round()</code> 和模板字面量将数字四舍五入为指定的小数位数。 省略第二个参数 <code>decimals</code> ，数字将被四舍五入到一个整数。</p> <div class="language- extra-class"><pre class="language-text"><code>const round = (n, decimals = 0) =&gt; Number(`${Math.round(`${n}e${decimals}`)}e-${decimals}`)
round(1.345, 2)                 // 1.35
round(1.345, 1)                 // 1.3
复制代码
</code></pre></div><h3 id="_4-3-数字补0操作"><a href="#_4-3-数字补0操作" aria-hidden="true" class="header-anchor">#</a> 4.3 数字补0操作</h3> <p>感谢网友 @JserWang @vczhan 提供 这个小技巧 有时候比如显示时间的时候有时候会需要把一位数字显示成两位，这时候就需要补0操作，可以使用<code>slice</code>和string的<code>padStart</code>方法</p> <div class="language- extra-class"><pre class="language-text"><code>const addZero1 = (num, len = 2) =&gt; (`0${num}`).slice(-len)
const addZero2 = (num, len = 2) =&gt; (`${num}`).padStart( len   , '0')
addZero1(3) // 03
 
addZero2(32,4)  // 0032
复制代码
</code></pre></div><h2 id="_5-数组"><a href="#_5-数组" aria-hidden="true" class="header-anchor">#</a> 5. 数组</h2> <h3 id="_5-1-reduce方法同时实现map和filter"><a href="#_5-1-reduce方法同时实现map和filter" aria-hidden="true" class="header-anchor">#</a> 5.1 reduce方法同时实现map和filter</h3> <p>假设现在有一个数列，你希望更新它的每一项（map的功能）然后筛选出一部分（filter的功能）。如果是先使用map然后filter的话，你需要遍历这个数组两次。 在下面的代码中，我们将数列中的值翻倍，然后挑选出那些大于50的数。</p> <div class="language- extra-class"><pre class="language-text"><code>const numbers = [10, 20, 30, 40];
const doubledOver50 = numbers.reduce((finalList, num) =&gt; {
  num = num * 2;
  if (num &gt; 50) {
    finalList.push(num);
  }
  return finalList;
}, []);
doubledOver50;            // [60, 80]
复制代码
</code></pre></div><h3 id="_5-2-统计数组中相同项的个数"><a href="#_5-2-统计数组中相同项的个数" aria-hidden="true" class="header-anchor">#</a> 5.2 统计数组中相同项的个数</h3> <p>很多时候，你希望统计数组中重复出现项的个数然后用一个对象表示。那么你可以使用reduce方法处理这个数组。</p> <p>下面的代码将统计每一种车的数目然后把总数用一个对象表示。</p> <div class="language- extra-class"><pre class="language-text"><code>var cars = ['BMW','Benz', 'Benz', 'Tesla', 'BMW', 'Toyota'];
var carsObj = cars.reduce(function (obj, name) {
  obj[name] = obj[name] ? ++obj[name] : 1;
  return obj;
}, {});
carsObj; // =&gt; { BMW: 2, Benz: 2, Tesla: 1, Toyota: 1 }
复制代码
</code></pre></div><h3 id="_5-3-使用解构来交换参数数值"><a href="#_5-3-使用解构来交换参数数值" aria-hidden="true" class="header-anchor">#</a> 5.3 使用解构来交换参数数值</h3> <p>有时候你会将函数返回的多个值放在一个数组里。我们可以使用数组解构来获取其中每一个值。</p> <div class="language- extra-class"><pre class="language-text"><code>let param1 = 1;
let param2 = 2;
[param1, param2] = [param2, param1];
console.log(param1) // 2
console.log(param2) // 1
复制代码
</code></pre></div><p>当然我们关于交换数值有不少其他办法：</p> <div class="language- extra-class"><pre class="language-text"><code>var temp = a; a = b; b = temp            
b = [a, a = b][0]                     
a = a + b; b = a - b; a = a - b        
复制代码
</code></pre></div><h3 id="_5-4-接收函数返回的多个结果"><a href="#_5-4-接收函数返回的多个结果" aria-hidden="true" class="header-anchor">#</a> 5.4 接收函数返回的多个结果</h3> <p>在下面的代码中，我们从/post中获取一个帖子，然后在/comments中获取相关评论。由于我们使用的是async/await，函数把返回值放在一个数组中。而我们使用数组解构后就可以把返回值直接赋给相应的变量。</p> <div class="language- extra-class"><pre class="language-text"><code>async function getFullPost(){
  return await Promise.all([
     fetch('/post'),
     fetch('/comments')
  ]);
}
const [post, comments] = getFullPost();
复制代码
</code></pre></div><h3 id="_5-5-将数组平铺到指定深度"><a href="#_5-5-将数组平铺到指定深度" aria-hidden="true" class="header-anchor">#</a> 5.5 将数组平铺到指定深度</h3> <p>使用递归，为每个深度级别 <code>depth</code> 递减 1 。 使用 <code>Array.reduce()</code> 和 <code>Array.concat()</code> 来合并元素或数组。 基本情况下，<code>depth</code> 等于 1 停止递归。 省略第二个参数，<code>depth</code> 只能平铺到 1 (单层平铺) 的深度。</p> <div class="language- extra-class"><pre class="language-text"><code>const flatten = (arr, depth = 1) =&gt;
  depth != 1
    ? arr.reduce((a, v) =&gt; a.concat(Array.isArray(v) ? flatten(v, depth - 1) : v), [])
    : arr.reduce((a, v) =&gt; a.concat(v), []);
flatten([1, [2], 3, 4]);                             // [1, 2, 3, 4]
flatten([1, [2, [3, [4, 5], 6], 7], 8], 2);           // [1, 2, 3, [4, 5], 6, 7, 8]
复制代码
</code></pre></div><h3 id="_5-6-数组的对象解构"><a href="#_5-6-数组的对象解构" aria-hidden="true" class="header-anchor">#</a> 5.6 数组的对象解构</h3> <p>数组也可以对象解构，可以方便的获取数组的第n个值</p> <div class="language- extra-class"><pre class="language-text"><code>const csvFileLine = '1997,John Doe,US,john@doe.com,New York';
const { 2: country, 4: state } = csvFileLine.split(',');
 
country            // US
state            // New Yourk
复制代码
</code></pre></div><h2 id="_6-对象"><a href="#_6-对象" aria-hidden="true" class="header-anchor">#</a> 6. 对象</h2> <h3 id="_6-1-使用解构删除不必要属性"><a href="#_6-1-使用解构删除不必要属性" aria-hidden="true" class="header-anchor">#</a> 6.1 使用解构删除不必要属性</h3> <p>有时候你不希望保留某些对象属性，也许是因为它们包含敏感信息或仅仅是太大了（just too big）。你可能会枚举整个对象然后删除它们，但实际上只需要简单的将这些无用属性赋值给变量，然后把想要保留的有用部分作为剩余参数就可以了。</p> <p>下面的代码里，我们希望删除_internal和tooBig参数。我们可以把它们赋值给internal和tooBig变量，然后在cleanObject中存储剩下的属性以备后用。</p> <div class="language- extra-class"><pre class="language-text"><code>let {_internal, tooBig, ...cleanObject} = {el1: '1', _internal:&quot;secret&quot;, tooBig:{}, el2: '2', el3: '3'};
 
console.log(cleanObject);                         // {el1: '1', el2: '2', el3: '3'}
复制代码
</code></pre></div><h3 id="_6-2-在函数参数中解构嵌套对象"><a href="#_6-2-在函数参数中解构嵌套对象" aria-hidden="true" class="header-anchor">#</a> 6.2 在函数参数中解构嵌套对象</h3> <p>在下面的代码中，engine是对象car中嵌套的一个对象。如果我们对engine的vin属性感兴趣，使用解构赋值可以很轻松地得到它。</p> <div class="language- extra-class"><pre class="language-text"><code>var car = {
  model: 'bmw 2018',
  engine: {
    v6: true,
    turbo: true,
    vin: 12345
  }
}
const modelAndVIN = ({model, engine: {vin}}) =&gt; {
  console.log(`model: ${model} vin: ${vin}`);
}
modelAndVIN(car); // =&gt; model: bmw 2018  vin: 12345
复制代码

</code></pre></div><h2 id="_7-代码复用"><a href="#_7-代码复用" aria-hidden="true" class="header-anchor">#</a> 7. 代码复用</h2> <h3 id="_7-1-object-key"><a href="#_7-1-object-key" aria-hidden="true" class="header-anchor">#</a> 7.1 Object [key]</h3> <p>虽然将 <code>foo.bar</code> 写成 <code>foo ['bar']</code> 是一种常见的做法，但是这种做法构成了编写可重用代码的基础。许多框架使用了这种方法，比如element的<a href="https://link.juejin.im/?target=http%3A%2F%2Felement-cn.eleme.io%2F%23%2Fzh-CN%2Fcomponent%2Fform%23biao-dan-yan-zheng" target="_blank" rel="noopener noreferrer">表单验证<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>请考虑下面这个验证函数的简化示例：</p> <div class="language- extra-class"><pre class="language-text"><code>function validate(values) {
  if(!values.first)
    return false;
  if(!values.last)
    return false;
  return true;
}
console.log(validate({first:'Bruce',last:'Wayne'})); // true
复制代码

</code></pre></div><p>上面的函数完美的完成验证工作。但是当有很多表单，则需要应用验证，此时会有不同的字段和规则。如果可以构建一个在运行时配置的通用验证函数，会是一个好选择。</p> <div class="language- extra-class"><pre class="language-text"><code>// object validation rules
const schema = {
  first: {
    required:true
  },
  last: {
    required:true
  }
}
 
// universal validation function
const validate = (schema, values) =&gt; {
  for(field in schema) {
    if(schema[field].required) {
      if(!values[field]) {
        return false;
      }
    }
  }
  return true;
}
console.log(validate(schema, {first:'Bruce'})); // false
console.log(validate(schema, {first:'Bruce',last:'Wayne'})); // true
复制代码

</code></pre></div><p>现在有了这个验证函数，我们就可以在所有窗体中重用，而无需为每个窗体编写自定义验证函数。</p> <p>~</p></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com/thisliuyang/javascript-tutorial/edit/master/docs/02-node_introduction.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">9/15/2019, 1:31:32 PM</span></div></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/01-web_concept.html" class="prev">
          Javascript 的 this 用法
        </a></span> <span class="next"><a href="/03-getting_started.html">
          Vue.js双向绑定的实现原理
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.fa27fcb7.js" defer></script><script src="/assets/js/7.ebbd53f9.js" defer></script>
  </body>
</html>
